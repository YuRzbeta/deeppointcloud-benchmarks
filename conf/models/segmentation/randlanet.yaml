models:

    Randlanet_mp:
        # Note: concat pos to x, so that FEAT = len(pos) + len(x) 
        class: randlanet.RandLANetSeg
        conv_type: "MESSAGE_PASSING"
        define_constants:
            L1_OUT: 32
            L2_OUT: 128
            CLS_MLP: 64
        down_conv:
          - module_name: RandlaBlock

            in_reshape_nn: [FEAT, L1_OUT // 4]

            #LocSE + Attentive Pooling 1: in = L1_OUT // 4, out = L1_OUT // 2
            neighbour_finder:
                module_name: KNNNeighbourFinder
                k: 16
            rel_point_pos_nn_1: [10, L1_OUT // 4, L1_OUT // 4]
            attention_nn_1: [L1_OUT // 2, L1_OUT, L1_OUT // 2]
            aggregation_nn_1: [L1_OUT // 2, L1_OUT // 2]

            #LocSE + Attentive Pooling 2: in = L1_OUT // 2, out = L1_OUT
            rel_point_pos_nn_2: [10, L1_OUT // 2, L1_OUT // 2]
            attention_nn_2: [L1_OUT, 2 * L1_OUT, L1_OUT]
            aggregation_nn_2: [L1_OUT, L1_OUT] 

            skip_nn: [FEAT, L1_OUT]
        
          - module_name: RandlaBlock
            sampler:
                module_name: RandomSampler
                ratio: 1/4

            in_reshape_nn: [L1_OUT, L2_OUT // 4]

            #LocSE + Attentive Pooling 1: in = L1_OUT, out = L2_OUT // 2
            neighbour_finder:
                module_name: KNNNeighbourFinder
                k: 16
            rel_point_pos_nn_1: [10, L2_OUT // 4, L2_OUT // 4]
            attention_nn_1: [L2_OUT // 2, L2_OUT, L2_OUT // 2]
            aggregation_nn_1: [L2_OUT // 2, L2_OUT // 2]

            #LocSE + Attentive Pooling 2: in = L2_OUT // 2, out = L2_OUT
            rel_point_pos_nn_2: [10, L2_OUT // 2, L2_OUT // 2]
            attention_nn_2: [L2_OUT, 2 * L2_OUT, L2_OUT]
            aggregation_nn_2: [L2_OUT, L2_OUT] 

            skip_nn: [L1_OUT, L2_OUT]

        flat_innermost:
            module_name: RandlaBaseModule
            nn: [L2_OUT, 2 * L2_OUT, L2_OUT]
        up_conv:
          - module_name: FPModule
            up_k: 1
            skip: True
            up_conv_nn: [2 * L1_OUT, L1_OUT, L1_OUT]
          - module_name: FPModule
            up_k: 1
            skip: True
            up_conv_nn: [2 * L1_OUT, CLS_MLP, CLS_MLP]
        mlp_cls:
            nn: [64, 64, 64, 64, 64]
            dropout: 0.5



    # RandLA-Net: Efficient Semantic Segmentation of Large-Scale Point Clouds (https://arxiv.org/pdf/1911.11236.pdf)
    Randlanet_Res:
        class: randlanet.RandLANetSeg
        conv_type: "MESSAGE_PASSING"
        down_conv:
            module_name: RandLANetRes
            ratio: [[1, 1], [0.5, 0.5]]
            indim: [3, 32]
            outdim: [32, 128]
            point_pos_nn:
                [[[10, 8, FEAT], [10, 16, 16]], [[10, 16, 32], [10, 32, 64]]]
            attention_nn:
                [
                    [[2 * FEAT, 8, 2 * FEAT], [32, 64, 32]],
                    [[64, 128, 64], [128, 256, 128]],
                ]
            down_conv_nn:
                [
                    [[2 * FEAT, 8, 16], [32, 64, 32]],
                    [[64, 64, 64], [128, 128, 128]],
                ]
        innermost:
            module_name: GlobalBaseModule
            aggr: max
            nn: [131, 128]
        up_conv:
            module_name: FPModule
            up_conv_nn: [[128 + 128, 128], [128 + 32, 64], [64 + FEAT, 64]]
            up_k: [1, 1, 1]
            skip: True
        mlp_cls:
            nn: [64, 64, 64, 64, 64]
            dropout: 0.5

    Randlanet_Conv:
        class: randlanet.RandLANetSeg
        conv_type: "MESSAGE_PASSING"
        down_conv:
            module_name: RandlaConv
            ratio: [0.25, 0.25, 0.25]
            k: [16, 16, 16]
            point_pos_nn: [[10, 8, FEAT], [10, 8, 16], [10, 16, 32]]
            attention_nn: [[2 * FEAT, 8, 2 * FEAT], [32, 64, 32], [64, 128, 64]]
            down_conv_nn: [[2 * FEAT, 8, 16], [32, 64, 32], [64, 128, 128]]
        innermost:
            module_name: GlobalBaseModule
            aggr: max
            nn: [131, 128]
        up_conv:
            module_name: FPModule
            up_conv_nn:
                [
                    [128 + 128, 128],
                    [128 + 32, 64],
                    [64 + 16, 64],
                    [64 + FEAT, 64],
                ]
            up_k: [1, 1, 1, 1]
            skip: True
        mlp_cls:
            nn: [64, 64, 64, 64, 64]
            dropout: 0.5
